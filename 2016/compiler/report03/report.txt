----------問１----------

プログラム例

末尾再帰を使ったループfib
nが自由変数なので引数n'として与えた

(* 書き換え前 *)

let fib_naive n =
  let rec fib_tailrec k fn1 fn =
    if k = n then
      fn
    else
      fib_tailrec (k+1) ((fn1+fn) mod 1000000007) fn1
  in
  fib_tailrec 0 1 0

(* 書き換え後 *)


let fib_naive n =
  let rec fib_tailrec n' k fn1 fn =
    if k = n' then
      fn
    else
      fib_tailrec n' (k+1) ((fn1+fn) mod 1000000007) fn1
  in
  fib_tailrec n 0 1 0

----------問３----------
1.
fの自由変数としてzが存在するのでクロージャが作られる
<Lf,{z}>
2.
gの自由変数は存在せず直接呼び(g 6)のみなので、クロージャは作られない

3.
fに自由変数は存在しないが、式の評価値が関数になっているのでクロージャが作られる（min-camlの実装では値としての関数はクロージャ呼びかラベル呼びかの区別がないので、すべてクロージャ呼びとして変数に束縛される）
<Lf,{}>
4.
iは自由変数hを持つのでクロージャが作られる。
<Li,{h}
gは自由変数を持たないが3.と同じ理由でクロージャが作られる
<Lg,{}>
5.
fは自由変数i,zが含まれるのでクロージャが作られる
<Lf,{i,z}>
iは自由変数を持たないが、タプル(i,f 7)の中身として返却されるので3.や4.のgと同じ理由でクロージャが作られる
<Li,{}>
6.
factは自由変数を持たず、直接呼び( fact (x-1) ,  fact 6 )のみなのでクロージャは作られない
